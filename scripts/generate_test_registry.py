#!/usr/bin/env python3
"""
Generate test registry from module metadata.

This script scans all module_info.yaml files and generates test manifests
that allow the test runners to automatically discover and run module tests.

Usage:
    python scripts/generate_test_registry.py

Generates:
    build/generated/unit_tests.txt        - Unit test paths
    build/generated/integration_tests.txt - Integration test paths
    build/generated/scientific_tests.txt  - Scientific test paths
    build/generated/test_registry_hash.txt - Validation hash

Author: Mimic Development Team
Date: 2025-11-12
Phase: Phase 4.2 (Test Architecture Refactor)
"""

import hashlib
import sys
from pathlib import Path

import yaml


def process_test_entries(test_value, module_path, repo_root, test_type, module_name):
    """
    Process test entries from module_info.yaml.

    Handles both formats:
    - String: single test file (legacy format for physics modules)
    - List: multiple test files (for shared utilities)

    Returns list of relative test paths.
    """
    test_paths = []

    if test_value is None:
        # No tests declared (allowed for test fixtures)
        return test_paths

    # Support both string (single test) and list (multiple tests)
    test_files = test_value if isinstance(test_value, list) else [test_value]

    for test_file in test_files:
        test_path = module_path / test_file
        if test_path.exists():
            rel_path = test_path.relative_to(repo_root)
            test_paths.append(str(rel_path))
        else:
            print(
                f"WARNING: {module_name} declares {test_type} test '{test_file}' but file not found"
            )

    return test_paths


def generate_test_registry():
    """Generate test registry from module metadata."""

    print("Generating test registry...")
    print("=" * 70)

    # Paths
    repo_root = Path(__file__).parent.parent
    module_dir = repo_root / "src" / "modules"
    output_dir = repo_root / "build" / "generated"

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Collect tests from all modules
    unit_tests = []
    integration_tests = []
    scientific_tests = []

    # Track modules for summary
    modules_found = []
    modules_with_tests = []

    # Scan for module metadata (including nested _system/test_fixture)
    module_info_files = []

    # Get top-level modules
    for item in sorted(module_dir.glob("*/module_info.yaml")):
        module_info_files.append(item)

    # Also check _system/test_fixture
    system_test_fixture = module_dir / "_system" / "test_fixture" / "module_info.yaml"
    if system_test_fixture.exists():
        module_info_files.append(system_test_fixture)

    for module_info_file in sorted(module_info_files):
        module_path = module_info_file.parent
        module_name = module_path.name

        # Skip template and system directories (but test_fixture from _system is included above)
        if module_name in ["_template", "_system", "_archive", "template", "generated"]:
            continue

        # Load metadata
        try:
            with open(module_info_file) as f:
                metadata = yaml.safe_load(f)
        except Exception as e:
            print(f"WARNING: Failed to load {module_info_file}: {e}")
            continue

        modules_found.append(module_name)

        # Get test declarations
        tests = metadata.get("module", {}).get("tests", {})

        has_tests = False

        # Process unit tests (supports both string and list formats)
        if "unit" in tests:
            found_tests = process_test_entries(
                tests["unit"], module_path, repo_root, "unit", module_name
            )
            unit_tests.extend(found_tests)
            if found_tests:
                has_tests = True

        # Process integration tests (supports both string and list formats)
        if "integration" in tests:
            found_tests = process_test_entries(
                tests["integration"], module_path, repo_root, "integration", module_name
            )
            integration_tests.extend(found_tests)
            if found_tests:
                has_tests = True

        # Process scientific tests (supports both string and list formats)
        if "scientific" in tests:
            found_tests = process_test_entries(
                tests["scientific"], module_path, repo_root, "scientific", module_name
            )
            scientific_tests.extend(found_tests)
            if found_tests:
                has_tests = True

        if has_tests:
            modules_with_tests.append(module_name)

    # Write test manifests
    unit_tests_file = output_dir / "unit_tests.txt"
    with open(unit_tests_file, "w") as f:
        f.write("# Auto-generated unit test registry\n")
        f.write("# DO NOT EDIT - Generated by scripts/generate_test_registry.py\n")
        f.write(f"# Found {len(unit_tests)} unit test(s)\n\n")
        for test_path in unit_tests:
            f.write(f"{test_path}\n")

    integration_tests_file = output_dir / "integration_tests.txt"
    with open(integration_tests_file, "w") as f:
        f.write("# Auto-generated integration test registry\n")
        f.write("# DO NOT EDIT - Generated by scripts/generate_test_registry.py\n")
        f.write(f"# Found {len(integration_tests)} integration test(s)\n\n")
        for test_path in integration_tests:
            f.write(f"{test_path}\n")

    scientific_tests_file = output_dir / "scientific_tests.txt"
    with open(scientific_tests_file, "w") as f:
        f.write("# Auto-generated scientific test registry\n")
        f.write("# DO NOT EDIT - Generated by scripts/generate_test_registry.py\n")
        f.write(f"# Found {len(scientific_tests)} scientific test(s)\n\n")
        for test_path in scientific_tests:
            f.write(f"{test_path}\n")

    # Generate validation hash
    hash_content = "\n".join(sorted(unit_tests + integration_tests + scientific_tests))
    registry_hash = hashlib.md5(hash_content.encode()).hexdigest()

    hash_file = output_dir / "test_registry_hash.txt"
    with open(hash_file, "w") as f:
        f.write(f"{registry_hash}\n")

    # Print summary
    print()
    print(f"Found {len(modules_found)} module(s):")
    for module in modules_found:
        marker = "✓" if module in modules_with_tests else " "
        print(f"  [{marker}] {module}")

    print()
    print("Test registry summary:")
    print(f"  Unit tests:        {len(unit_tests)}")
    print(f"  Integration tests: {len(integration_tests)}")
    print(f"  Scientific tests:  {len(scientific_tests)}")

    print()
    print("Generated files:")
    print(f"  ✓ {unit_tests_file.relative_to(repo_root)}")
    print(f"  ✓ {integration_tests_file.relative_to(repo_root)}")
    print(f"  ✓ {scientific_tests_file.relative_to(repo_root)}")
    print(f"  ✓ {hash_file.relative_to(repo_root)}")

    print()
    print("=" * 70)
    print("✓ TEST REGISTRY GENERATION COMPLETED")
    print("=" * 70)

    return 0


if __name__ == "__main__":
    sys.exit(generate_test_registry())
