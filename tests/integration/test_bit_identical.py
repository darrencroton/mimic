#!/usr/bin/env python3
"""
Bit-Identical Regression Test

Validates: Output reproducibility and regression detection
Phase: Phase 2 (Testing Framework)

This test validates that Mimic produces bit-identical output across runs:
- Establishes baseline checksums for output files
- Detects any changes in output (regressions)
- Verifies reproducibility

Test cases:
  - test_establish_baseline: Create baseline checksums
  - test_bit_identical_reproduction: Verify identical output
  - test_detect_changes: Verify detection capability

Author: Mimic Testing Team
Date: 2025-11-08
"""

import subprocess
import sys
from pathlib import Path
import hashlib

# Repository root
REPO_ROOT = Path(__file__).parent.parent.parent
TEST_DATA_DIR = REPO_ROOT / "tests" / "data"
MIMIC_EXE = REPO_ROOT / "mimic"
BASELINE_FILE = TEST_DATA_DIR / "expected" / "baseline_checksums.txt"


def compute_md5(file_path):
    """
    Compute MD5 checksum of a file

    Args:
        file_path (Path): Path to file

    Returns:
        str: MD5 checksum (hex string)
    """
    md5 = hashlib.md5()
    with open(file_path, 'rb') as f:
        # Read in chunks to handle large files
        for chunk in iter(lambda: f.read(4096), b""):
            md5.update(chunk)
    return md5.hexdigest()


def run_mimic():
    """
    Run Mimic on test parameter file

    Returns:
        tuple: (returncode, output_files)
    """
    param_file = TEST_DATA_DIR / "test.par"

    result = subprocess.run(
        [str(MIMIC_EXE), str(param_file)],
        cwd=str(REPO_ROOT),
        capture_output=True,
        text=True
    )

    # Find output files
    output_dir = TEST_DATA_DIR / "expected" / "test"
    output_files = []
    if output_dir.exists():
        # Binary format uses redshift-based naming: model_z{redshift}_{filenr}
        output_files = list(output_dir.glob("model_z*"))

    return result.returncode, output_files


def establish_baseline():
    """
    Establish baseline checksums for regression testing

    Returns:
        dict: {filename: md5_checksum}
    """
    print("Establishing baseline checksums...")

    # Run Mimic
    returncode, output_files = run_mimic()
    assert returncode == 0, "Mimic execution failed"

    # Compute checksums
    checksums = {}
    for output_file in output_files:
        md5 = compute_md5(output_file)
        checksums[output_file.name] = md5
        print(f"  {output_file.name}: {md5}")

    return checksums


def save_baseline(checksums):
    """
    Save baseline checksums to file

    Args:
        checksums (dict): {filename: md5_checksum}
    """
    # Ensure directory exists
    BASELINE_FILE.parent.mkdir(parents=True, exist_ok=True)

    with open(BASELINE_FILE, 'w') as f:
        f.write("# Baseline checksums for regression testing\n")
        f.write("# Generated by test_bit_identical.py\n")
        f.write("# Format: filename md5_checksum\n")
        f.write("#\n")
        for filename, checksum in sorted(checksums.items()):
            f.write(f"{filename} {checksum}\n")

    print(f"Baseline saved to: {BASELINE_FILE}")


def load_baseline():
    """
    Load baseline checksums from file

    Returns:
        dict: {filename: md5_checksum} or None if no baseline exists
    """
    if not BASELINE_FILE.exists():
        return None

    checksums = {}
    with open(BASELINE_FILE) as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            parts = line.split()
            if len(parts) >= 2:
                filename = parts[0]
                checksum = parts[1]
                checksums[filename] = checksum

    return checksums


def test_establish_baseline():
    """
    Test baseline establishment

    Expected: Baseline checksums created and saved
    Validates: Baseline generation process
    """
    print("Testing baseline establishment...")

    if not MIMIC_EXE.exists():
        print(f"  Skipping (Mimic not built)")
        return

    # Establish and save baseline
    checksums = establish_baseline()
    assert len(checksums) > 0, "No output files generated"

    save_baseline(checksums)

    # Verify baseline file created
    assert BASELINE_FILE.exists(), "Baseline file not created"

    print(f"  ✓ Baseline established ({len(checksums)} files)")


def test_bit_identical_reproduction():
    """
    Test that running Mimic again produces identical output

    Expected: Checksums match baseline exactly
    Validates: Bit-identical reproducibility
    """
    print("Testing bit-identical reproduction...")

    if not MIMIC_EXE.exists():
        print(f"  Skipping (Mimic not built)")
        return

    # Load baseline (create if doesn't exist)
    baseline = load_baseline()
    if baseline is None:
        print("  No baseline found, establishing it...")
        checksums = establish_baseline()
        save_baseline(checksums)
        baseline = checksums

    # Run Mimic again
    returncode, output_files = run_mimic()
    assert returncode == 0, "Mimic execution failed"

    # Compute new checksums
    new_checksums = {}
    for output_file in output_files:
        new_checksums[output_file.name] = compute_md5(output_file)

    # Compare to baseline
    mismatches = []
    for filename, expected_checksum in baseline.items():
        actual_checksum = new_checksums.get(filename)
        if actual_checksum is None:
            mismatches.append(f"{filename}: MISSING in new run")
        elif actual_checksum != expected_checksum:
            mismatches.append(
                f"{filename}: CHANGED\n"
                f"    Expected: {expected_checksum}\n"
                f"    Got:      {actual_checksum}"
            )

    # Check for new files not in baseline
    for filename in new_checksums:
        if filename not in baseline:
            mismatches.append(f"{filename}: NEW file not in baseline")

    # Report results
    if mismatches:
        print(f"  ✗ Output changed from baseline:")
        for mismatch in mismatches:
            print(f"    {mismatch}")
        assert False, f"Output not bit-identical ({len(mismatches)} differences)"
    else:
        print(f"  ✓ Output is bit-identical to baseline")
        print(f"  Verified {len(baseline)} file(s)")


def test_baseline_file_format():
    """
    Test that baseline file has correct format

    Expected: Baseline file is readable and well-formed
    Validates: Baseline file integrity
    """
    print("Testing baseline file format...")

    # Establish baseline if needed
    if not BASELINE_FILE.exists():
        checksums = establish_baseline()
        save_baseline(checksums)

    # Load and validate
    baseline = load_baseline()
    assert baseline is not None, "Could not load baseline"
    assert len(baseline) > 0, "Baseline is empty"

    # Check format
    for filename, checksum in baseline.items():
        assert isinstance(filename, str), f"Filename should be string: {filename}"
        assert isinstance(checksum, str), f"Checksum should be string: {checksum}"
        assert len(checksum) == 32, f"MD5 checksum should be 32 hex chars: {checksum}"
        assert all(c in '0123456789abcdef' for c in checksum.lower()), \
            f"Checksum should be hex: {checksum}"

    print(f"  ✓ Baseline file format is valid")
    print(f"  Contains {len(baseline)} checksum(s)")


def main():
    """
    Main test runner

    Executes all test cases and reports results.
    """
    print("=" * 60)
    print("Integration Test: Bit-Identical Regression")
    print("=" * 60)
    print(f"Repository root: {REPO_ROOT}")
    print(f"Mimic executable: {MIMIC_EXE}")
    print(f"Baseline file: {BASELINE_FILE}")
    print()

    # Check prerequisites
    if not MIMIC_EXE.exists():
        print(f"ERROR: Mimic executable not found: {MIMIC_EXE}")
        print("Build it first with: make")
        return 1

    tests = [
        test_establish_baseline,
        test_bit_identical_reproduction,
        test_baseline_file_format,
    ]

    passed = 0
    failed = 0

    # ANSI color codes
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    NC = '\033[0m'  # No Color

    for test in tests:
        print()
        try:
            test()
            passed += 1
        except AssertionError as e:
            print(f"{RED}✗ FAIL: {test.__name__}{NC}")
            print(f"  {e}")
            failed += 1
        except Exception as e:
            print(f"{RED}✗ ERROR: {test.__name__}{NC}")
            print(f"  {e}")
            failed += 1

    print()
    print("=" * 60)
    print("Test Summary")
    print("=" * 60)
    print(f"Passed: {passed}")
    print(f"Failed: {failed}")
    print(f"Total:  {passed + failed}")
    print("=" * 60)

    if failed == 0:
        print(f"{GREEN}✓ All tests passed!{NC}")
        return 0
    else:
        print(f"{RED}✗ {failed} test(s) failed{NC}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
